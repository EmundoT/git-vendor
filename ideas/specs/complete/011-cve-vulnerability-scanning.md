# Spec 011: CVE/Vulnerability Scanning

> **Status:** In Progress
> **Priority:** P0 - Security Requirement
> **Effort:** 7-10 days
> **Dependencies:** 003 (Metadata Enrichment)
> **Blocks:** 020 (Audit)

---

## Problem Statement

Snyk, Grype, and Trivy scan package manifests (`package.json`, `go.mod`, `requirements.txt`) for vulnerabilities—but they cannot scan vendored source code that doesn't appear in any manifest. This creates a blind spot: vendored code with known CVEs goes undetected.

git-vendor fills this gap by scanning vendored dependencies against the OSV.dev vulnerability database.

## Solution Overview

New command `git vendor scan` that queries OSV.dev for known vulnerabilities in vendored dependencies.

```bash
git vendor scan [--format table|json] [--fail-on critical|high|medium|low]
```

## Detailed Design

### 1. Command Interface

```bash
# Default: table output, no failure threshold
git vendor scan

# JSON output
git vendor scan --format json

# CI mode: fail on high or critical
git vendor scan --fail-on high

# Combined
git vendor scan --format json --fail-on critical
```

### 2. OSV.dev API Integration

#### Query Strategy

For each vendored dependency, query OSV.dev using:

1. **PURL query** (preferred) - Package URL with version tag
2. **Commit query** (fallback) - Git repository URL + commit SHA

```http
POST https://api.osv.dev/v1/query
Content-Type: application/json

{
  "package": {
    "purl": "pkg:github/owner/repo@v1.2.3"
  }
}
```

Or for commit-based:

```http
POST https://api.osv.dev/v1/query
Content-Type: application/json

{
  "commit": "abc123...",
  "package": {
    "name": "github.com/owner/repo",
    "ecosystem": "Go"
  }
}
```

#### Response Handling

```json
{
  "vulns": [
    {
      "id": "GHSA-xxxx-xxxx-xxxx",
      "summary": "Remote code execution in...",
      "details": "...",
      "aliases": ["CVE-2024-1234"],
      "severity": [
        {
          "type": "CVSS_V3",
          "score": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        }
      ],
      "affected": [
        {
          "package": {
            "name": "github.com/owner/repo",
            "ecosystem": "Go"
          },
          "ranges": [
            {
              "type": "SEMVER",
              "events": [
                {"introduced": "1.0.0"},
                {"fixed": "1.2.4"}
              ]
            }
          ]
        }
      ],
      "references": [
        {
          "type": "ADVISORY",
          "url": "https://github.com/owner/repo/security/advisories/GHSA-xxxx"
        }
      ]
    }
  ]
}
```

### 3. Output Formats

#### Table Format (default)

```
Scanning vendored dependencies for vulnerabilities...

  some-lib (v1.2.3)
    ✗ CVE-2024-1234 [CRITICAL] Remote code execution vulnerability
      Fixed in: v1.2.4
      https://nvd.nist.gov/vuln/detail/CVE-2024-1234

    ✗ CVE-2024-5678 [HIGH] Information disclosure
      Fixed in: v1.2.5
      https://nvd.nist.gov/vuln/detail/CVE-2024-5678

  other-lib (abc1234)
    ⚠ Unable to scan: No version tag, commit not in OSV database

  clean-lib (v2.0.0)
    ✓ No vulnerabilities found

Summary: 3 dependencies scanned
  ✗ 2 vulnerabilities found (1 critical, 1 high)
  ⚠ 1 dependency could not be scanned

Result: FAIL (critical vulnerabilities found)
```

#### JSON Format

```json
{
  "schema_version": "1.0",
  "timestamp": "2026-02-04T12:00:00Z",
  "summary": {
    "total_dependencies": 3,
    "scanned": 2,
    "not_scanned": 1,
    "vulnerabilities": {
      "critical": 1,
      "high": 1,
      "medium": 0,
      "low": 0,
      "total": 2
    },
    "result": "FAIL"
  },
  "dependencies": [
    {
      "name": "some-lib",
      "version": "v1.2.3",
      "commit": "abc123...",
      "scan_status": "scanned",
      "vulnerabilities": [
        {
          "id": "CVE-2024-1234",
          "aliases": ["GHSA-xxxx-xxxx-xxxx"],
          "severity": "CRITICAL",
          "cvss_score": 9.8,
          "summary": "Remote code execution vulnerability",
          "fixed_version": "v1.2.4",
          "references": [
            "https://nvd.nist.gov/vuln/detail/CVE-2024-1234"
          ]
        }
      ]
    },
    {
      "name": "other-lib",
      "version": null,
      "commit": "def456...",
      "scan_status": "not_scanned",
      "scan_reason": "No version tag, commit not in OSV database",
      "vulnerabilities": []
    },
    {
      "name": "clean-lib",
      "version": "v2.0.0",
      "commit": "ghi789...",
      "scan_status": "scanned",
      "vulnerabilities": []
    }
  ]
}
```

### 4. Exit Codes

| Code | Meaning | When |
|------|---------|------|
| 0 | PASS | No vulnerabilities at or above threshold |
| 1 | FAIL | Vulnerabilities found at or above threshold |
| 2 | WARN | Some dependencies could not be scanned |

With `--fail-on`:
- `--fail-on critical` → exit 1 only if critical vulns found
- `--fail-on high` → exit 1 if critical or high vulns found
- `--fail-on medium` → exit 1 if critical, high, or medium vulns found
- `--fail-on low` → exit 1 if any vulns found

### 5. Caching Strategy

Cache responses in `.git-vendor-cache/osv/`:

```
.git-vendor-cache/
└── osv/
    ├── github.com_owner_some-lib_v1.2.3.json
    └── github.com_owner_other-lib_abc1234.json
```

- Cache TTL: 24 hours (configurable via `GIT_VENDOR_CACHE_TTL`)
- Cache key: `{purl_or_commit_hash}.json`
- Stale cache: Use if network unavailable, warn user

### 6. Implementation

#### Core Scanner

```go
type VulnScanner struct {
    client    *http.Client
    cacheDir  string
    cacheTTL  time.Duration
}

type ScanResult struct {
    SchemaVersion string           `json:"schema_version"`
    Timestamp     time.Time        `json:"timestamp"`
    Summary       ScanSummary      `json:"summary"`
    Dependencies  []DependencyScan `json:"dependencies"`
}

type DependencyScan struct {
    Name            string          `json:"name"`
    Version         *string         `json:"version"`
    Commit          string          `json:"commit"`
    ScanStatus      string          `json:"scan_status"` // scanned, not_scanned
    ScanReason      string          `json:"scan_reason,omitempty"`
    Vulnerabilities []Vulnerability `json:"vulnerabilities"`
}

type Vulnerability struct {
    ID           string   `json:"id"`
    Aliases      []string `json:"aliases"`
    Severity     string   `json:"severity"`
    CVSSScore    float64  `json:"cvss_score,omitempty"`
    Summary      string   `json:"summary"`
    FixedVersion string   `json:"fixed_version,omitempty"`
    References   []string `json:"references"`
}
```

#### OSV Client

```go
func (s *VulnScanner) queryOSV(dep LockDetails) ([]osvVuln, error) {
    // Check cache first
    cacheKey := s.getCacheKey(dep)
    if cached, ok := s.loadFromCache(cacheKey); ok {
        return cached, nil
    }

    // Build query
    query := s.buildQuery(dep)

    // Make request with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    req, _ := http.NewRequestWithContext(ctx, "POST", "https://api.osv.dev/v1/query", query)
    req.Header.Set("Content-Type", "application/json")

    resp, err := s.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("OSV query failed: %w", err)
    }
    defer resp.Body.Close()

    // Handle rate limiting
    if resp.StatusCode == 429 {
        retryAfter := resp.Header.Get("Retry-After")
        return nil, fmt.Errorf("rate limited, retry after %s", retryAfter)
    }

    var result osvResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    // Cache result
    s.saveToCache(cacheKey, result.Vulns)

    return result.Vulns, nil
}
```

#### CVSS to Severity Mapping

```go
func cvssToSeverity(score float64) string {
    switch {
    case score >= 9.0:
        return "CRITICAL"
    case score >= 7.0:
        return "HIGH"
    case score >= 4.0:
        return "MEDIUM"
    case score > 0:
        return "LOW"
    default:
        return "UNKNOWN"
    }
}
```

#### Batch Queries

OSV.dev supports batch queries (up to 1000 packages):

```go
func (s *VulnScanner) batchQuery(deps []LockDetails) (map[string][]osvVuln, error) {
    queries := []osvQuery{}
    for _, dep := range deps {
        queries = append(queries, s.buildQuery(dep))
    }

    // POST to /v1/querybatch
    req := osvBatchRequest{Queries: queries}
    // ...
}
```

### 7. Limitations Documentation

Clearly communicate in help text and docs:

```
LIMITATIONS:
  • Only scans dependencies from public open-source packages tracked by OSV.dev
  • Code vendored from internal/private repos cannot have CVE data
  • Commit-level queries may miss vulnerabilities announced against version ranges
  • This is a best-effort scan, not a guarantee of security
```

### 8. Rate Limiting

OSV.dev has generous limits but we should be good citizens:

- Batch queries where possible (reduces API calls)
- Cache all responses
- Exponential backoff on 429 responses
- Document that users with many dependencies may hit limits

## Test Plan

### Unit Tests

```go
func TestQueryOSV_WithKnownCVE(t *testing.T) {
    // Mock OSV response with known CVE
    // Verify parsed correctly
}

func TestQueryOSV_NoCVEs(t *testing.T) {
    // Mock OSV response with no vulns
    // Verify empty result
}

func TestQueryOSV_RateLimited(t *testing.T) {
    // Mock 429 response
    // Verify appropriate error
}

func TestCVSSToSeverity(t *testing.T) {
    tests := []struct {
        score    float64
        severity string
    }{
        {9.8, "CRITICAL"},
        {7.5, "HIGH"},
        {5.0, "MEDIUM"},
        {2.0, "LOW"},
        {0.0, "UNKNOWN"},
    }
    // ...
}

func TestCaching(t *testing.T) {
    // First query hits API
    // Second query uses cache
    // After TTL, query hits API again
}
```

### Integration Tests

1. Scan dependency with known historical CVE (e.g., log4j if Java, or Go vuln)
2. Scan dependency with no CVEs
3. Verify `--fail-on` exit codes work correctly
4. Verify JSON output is valid and complete
5. Test offline mode with cached data
6. Test rate limit handling

### End-to-End Test

Vendor a specific version of a package with a known patched CVE:
```yaml
vendors:
  - name: test-vuln-pkg
    url: https://github.com/owner/pkg-with-cve
    specs:
      - ref: v1.0.0  # Version with known CVE
```

Run `git vendor scan` and verify the CVE is detected.

## Acceptance Criteria

- [ ] Correctly identifies known CVEs for vendored dependencies from well-known packages
- [ ] `--fail-on` exits with code 1 when threshold exceeded
- [ ] JSON output includes full CVE details for each finding
- [ ] Gracefully handles: no network, API rate limits, unresolvable packages
- [ ] Clearly communicates when a dependency cannot be scanned (internal repo, no version mapping)
- [ ] Results are cached for 24 hours
- [ ] Batch queries used to minimize API calls
- [ ] Limitations are documented in help text and docs

## Rollout Plan

1. Implement OSV.dev client with caching
2. Implement CVSS parsing and severity mapping
3. Add `git vendor scan` command
4. Implement table and JSON output formatters
5. Add `--fail-on` threshold logic
6. Write integration tests against real OSV.dev API
7. Document limitations clearly
8. Release in v1.2.0

## Open Questions

1. **Ecosystem detection:** How to determine ecosystem (Go, npm, PyPI) for PURL? Use file extension analysis of vendored files? Default to generic?

2. **Version matching:** If vendored at commit that's between tags, which version range to query? Current spec: use nearest older tag if available.

3. **Multiple ecosystems:** A repo may contain code in multiple languages. Should we generate PURLs for each? Current spec: use primary ecosystem based on URL (github.com/x/y → Go ecosystem).

## References

- ROADMAP.md Feature 2.2
- OSV.dev API: https://osv.dev/docs/
- OSV Schema: https://ossf.github.io/osv-schema/
- CVSS v3.1 Specification: https://www.first.org/cvss/v3.1/specification-document
